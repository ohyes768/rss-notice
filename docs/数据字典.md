# RSS Notice Service - 数据字典

## 文档信息

- **项目名称**: RSS Notice Service
- **数据库类型**: SQLite
- **版本**: v1.0.0
- **创建日期**: 2026-02-10
- **最后更新**: 2026-02-10

---

## 1. 数据库概览

### 1.1 数据库文件

- **文件路径**: `data/rss_notice.db`
- **数据库类型**: SQLite 3.x
- **字符集**: UTF-8

### 1.2 数据表列表

| 表名 | 说明 | 记录数 |
|------|------|--------|
| articles | 文章记录表 | 取决于使用情况 |

---

## 2. 表结构详解

### 2.1 articles（文章记录表）

#### 2.1.1 表信息

- **表名**: `articles`
- **说明**: 存储所有已处理的文章记录
- **主键**: `id`

#### 2.1.2 字段列表

| 字段名 | 数据类型 | 长度 | 允许NULL | 默认值 | 说明 |
|--------|---------|------|---------|--------|------|
| id | TEXT | - | ❌ | - | 文章唯一标识，MD5(文章链接) |
| tag | TEXT | - | ❌ | - | RSS 源的 TAG 标识 |
| title | TEXT | - | ❌ | - | 文章标题 |
| link | TEXT | - | ❌ | - | 文章链接（原始 URL） |
| published | TEXT | - | ✅ | - | 发布时间（ISO 8601 格式） |
| author | TEXT | - | ✅ | - | 作者名称 |
| created_at | TEXT | - | ❌ | - | 记录创建时间（ISO 8601 格式） |

#### 2.1.3 索引

```sql
-- TAG 索引（用于按 TAG 查询）
CREATE INDEX idx_tag ON articles(tag);

-- 创建时间索引（用于按时间清理）
CREATE INDEX idx_created_at ON articles(created_at);
```

#### 2.1.4 示例数据

```sql
INSERT INTO articles VALUES (
  'a113ffbd1c83c2969a793ba0bd1b69ae',  -- id
  'touzi',                              -- tag
  '看到了巨机',                          -- title
  'http://mp.weixin.qq.com/s/...',       -- link
  '2026-02-08T13:39:00',                -- published
  NULL,                                 -- author
  '2026-02-10T23:24:48.123456'          -- created_at
);
```

---

## 3. 数据字典变更记录

### 2026-02-10 v1.0.0 - 初始版本

**新增表**:
- ✅ `articles` - 文章记录表

**新增字段**:
- ✅ `id` - 文章唯一标识（主键）
- ✅ `tag` - RSS 源标识
- ✅ `title` - 文章标题
- ✅ `link` - 文章链接
- ✅ `published` - 发布时间
- ✅ `author` - 作者
- ✅ `created_at` - 创建时间

**变更记录**:
- 初始版本从零开始创建数据库结构

---

## 4. 数据模型映射

### 4.1 数据库表 → Python 对象

**articles 表 → Article 模型**:

```python
class Article(BaseModel):
    id: str              # id
    title: str           # title
    link: str            # link
    published: Optional[datetime]  # published
    author: Optional[str]          # author
    markdown: str        # （计算字段，不存储）
```

**RSS 源元信息 → RSSCheckResponse 模型**:

```python
class RSSCheckResponse(BaseModel):
    feed_title: str           # 从 RSS feed 实时获取
    feed_url: str            # 请求的 RSS URL
    feed_updated: Optional[datetime]  # RSS 源最后更新时间（计算字段，不存储）
    check_time: datetime     # 检查时间（自动生成）
    new_count: int           # 新文章数量（计算）
    articles: List[Article]  # 新文章列表
```

### 4.2 字段类型映射

| SQLite 类型 | Python 类型 | 说明 |
|-------------|-------------|------|
| TEXT | str | 字符串 |
| TEXT | datetime | ISO 8601 格式的时间字符串 |

---

## 5. 数据约束

### 5.1 主键约束

```sql
PRIMARY KEY (id)
```

**说明**:
- `id` 字段为主键
- 使用 MD5(article_link) 生成，确保全局唯一
- 同一篇文章不会重复插入

### 5.2 非空约束

```sql
NOT NULL: id, tag, title, link, created_at
```

**说明**:
- 这些字段必须有值
- `published` 和 `author` 可以为空（可选字段）

### 5.3 唯一性约束

**业务层面唯一性**:
- 同一个 `id`（即同一篇文章链接）只能存在一条记录
- 同一 TAG 下的文章去重：`id + tag` 组合唯一

---

## 6. 数据生命周期

### 6.1 数据创建

**触发条件**: 调用 `/api/rss/check` 接口检测到新文章

**创建流程**:
1. 拉取 RSS 源的所有文章
2. 对比数据库，筛选出新文章
3. 插入新文章记录到 `articles` 表

**SQL 操作**:
```sql
INSERT INTO articles (id, tag, title, link, published, author, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
```

### 6.2 数据查询

**查询场景 1**: 检查文章是否已处理

```sql
SELECT 1 FROM articles WHERE id = ? AND tag = ? LIMIT 1
```

**查询场景 2**: 清除指定 TAG 的记录

```sql
SELECT COUNT(*) FROM articles WHERE tag = ?
```

**查询场景 3**: 清除指定天数的记录

```sql
SELECT COUNT(*) FROM articles WHERE created_at >= ?
```

### 6.3 数据删除

**删除场景 1**: 清除所有记录

```sql
DELETE FROM articles
```

**删除场景 2**: 清除指定 TAG 的记录

```sql
DELETE FROM articles WHERE tag = ?
```

**删除场景 3**: 清除指定天数的记录

```sql
DELETE FROM articles WHERE created_at >= ?
```

**删除场景 4**: 组合条件删除

```sql
DELETE FROM articles WHERE tag = ? AND created_at >= ?
```

---

## 7. 数据迁移

### 7.1 旧版本升级

**场景**: 从没有 tag 字段的旧版本升级

**迁移脚本**:
```python
# 检查表结构
cursor = conn.execute("PRAGMA table_info(articles)")
columns = [row[1] for row in cursor.fetchall()]

# 如果没有 tag 列，则添加
if 'tag' not in columns:
    conn.execute("ALTER TABLE articles ADD COLUMN tag TEXT DEFAULT 'default'")
    conn.commit()
```

### 7.2 数据备份

**备份方式**: 直接复制数据库文件

```bash
cp data/rss_notice.db data/rss_notice.db.backup
```

### 7.3 数据恢复

**恢复方式**: 替换数据库文件

```bash
cp data/rss_notice.db.backup data/rss_notice.db
```

---

## 8. 性能优化

### 8.1 索引优化

**已创建的索引**:
- `idx_tag`: 加速按 TAG 查询
- `idx_created_at`: 加速按时间清理

**查询性能**:
- 按检查文章是否已处理: O(log n)
- 按 TAG 删除: O(log n + m)，m 为该 TAG 的文章数

### 8.2 存储优化

**预估存储空间**:
- 每条记录约 500 bytes
- 1000 条记录约 500 KB
- 10000 条记录约 5 MB

**建议**:
- 定期清理旧数据（如 30 天前）
- 避免单表记录超过 100 万条

---

## 9. 数据安全

### 9.1 敏感信息

**不存储**:
- ❌ RSS 源的密钥或认证信息
- ❌ 用户个人数据
- ❌ 文章全文内容

**只存储元数据**:
- ✅ 文章标题、链接、发布时间、作者

### 9.2 数据隔离

**隔离方式**: 按 TAG 隔离不同 RSS 源

- 不同 TAG 的文章互不影响
- 清除某个 TAG 不会影响其他 TAG

---

## 10. 数据字典使用指南

### 10.1 开发参考

**新增字段时**:
1. 更新此文档
2. 修改 `models.py` 中的 Pydantic 模型
3. 更新数据库迁移脚本
4. 更新 API 接口文档

### 10.2 运维参考

**定期清理**:
```bash
# 每周清理最近 30 天的数据
curl -X POST "http://localhost:8020/api/rss/refresh?days=30"
```

**数据备份**:
```bash
# 定期备份数据库文件
cp data/rss_notice.db backups/rss_notice_$(date +%Y%m%d).db
```

### 10.3 故障排查

**问题**: 重复通知同一篇文章

**排查步骤**:
1. 检查 `id` 字段是否重复（主键约束）
2. 检查查询条件是否包含 `tag` 参数
3. 检查 `is_article_processed()` 方法的实现

**问题**: 按时间清理不生效

**排查步骤**:
1. 检查 `created_at` 字段的值
2. 检查时间比较逻辑（`>=` vs `<=`）
3. 查看服务日志确认删除的记录数
